---
title: "openpopscr"
author: "R. Glennie"
date: "`r Sys.Date()`"
#output: pdf_document
output: rmarkdown::html_vignette
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{openpopscr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

During capture-recapture surveys that span a time comparable to the 
temporal scale at which a population evolves, animals can die, migrate, or be born. 
Open population capture-recapture models allow for these population processes. 

This package can fit open population Jolly-Seber spatial capture-recapture
models by maximum likelihood (See @glennie2017, @borchers2008). This guide
describes how to read in your data, fit some models, and obtain inference.


## Reading in Data 

It is assumed you have a `capthist` and `mesh` object for your data, built using 
the `secr` package (@secr). Here, example data provided with this package is 
used.  

```{r, fig.show='hold'}
# load package 
library(openpopscr)
# load example data 
data("openpop_example")
capture_history <- openpop_example$capture_history
mesh <- openpop_example$mesh
```

The example survey consists a 7 x 7 array of detectors with 10 capture occasions.
Over the survey, `r dim(capture_history)[1] ` unique individuals are detected. 
Detectors record the number of times each individual was seen within each 
occasion and individuals can be seen on multiple detectors per occasion.

In `openpopscr`, the data is stored in a single object called an ScrData object.
A new ScrData object is created using the $new method with the capture history
and mesh provided as arguments. Typing the name of the ScrData object into 
the console returns the visual and numerical summary of the data provided 
by the `secr` package.

```{r, fig.show='hold', fig.align='center', fig.width = 5, fig.height = 5}
scr_dat <- ScrData$new(capture_history, mesh)
scr_dat
```

If the capture occasions occur at irregular intervals, this should be included. 
A vector of times at which each occasion began, `t`, can be used to create the data 
object with `ScrData$new(capture_history, mesh, t)`. 

## Data exploration 

The ScrData object can be queried to return information about the data stored.
The commands ``scr_dat$capthist()``, ``scr_dat$traps()``, ``scr_dat$mesh()``,
and ``scr_dat$time()``return the capture history, traps, mesh and time objects
respectively.

Further information on the data is available:
```{r}
# get number of unique individuals seen 
scr_dat$n()
```
```{r}
# get number of occasions in the survey 
scr_dat$n_occasions()
```
```{r}
# get number of traps in the survey 
scr_dat$n_traps()
```
```{r}
# get number of mesh points in the survey 
scr_dat$n_meshpts()
```
```{r}
# get total area of the mesh 
scr_dat$area()
```
```{r}
# get matrix of distances between each trap and each mesh point 
dist <- scr_dat$distances()
# e.g. distances from trap 1 to first 6 mesh points 
head(dist[1,])
```

## Fitting the Jolly-Seber model

The Jolly-Seber model is another type of object, `JsModel`. It is also created
with the `$new` command with arguments giving the ScrData object and initial
parameter values.

Parameters can depend on covariates that vary by detector or by occasion. 
Parameters cannot depend on individual-level or spatial covariates. Covariates
are included similar to formulae used to specify a linear model in `R` using the
`lm` command; however, as there are multiple parameters that may depend on 
covariates, the formulae are given in a list. 

For a model where all parameters are constant, an intercept-only formula is 
specified for each parameter. Sensible starting values for each parameter 
are also required: for beta, phi and D this ought to be possible to deduce from
knowledge of the study species; reasonable values for lambda0 and sigma can be 
found by fitting a standard secr model to the data. 
```{r}
# list formulae for parameters (intercept-only models)
par <- list(lambda0 ~ 1, 
            sigma ~ 1, 
            beta ~ 1, 
            phi ~ 1)

# guess a reasonable start value for each parameter 
start <- list(lambda0 = 2.0, 
              sigma = 100, 
              beta = 0.2, 
              phi = 0.5, 
              D = 100)

# create JsModel object 
mod <- JsModel$new(par, scr_dat, start)
```

Model fitting time can be reduced using parallel computing. When creating the 
model object, you can set the number of processor cores the package can use. 
If your computer is set up for parallelisation, then the model will fit faster.
The number of cores used by the model is set using an additional argument. For example
to fit the model using 4 processor cores: 
```{r, eval = FALSE}
mod <- JsModel$new(par, scr_dat, start, num_cores = 4)
```

If you are not sure how many cores you have available, the `parallel` package
can be used to find this out: 
```{r, eval = FALSE}
library(parallel)
detectCores()
```

Creating the model object does not fit the model, the `$fit` command does this. 
(The model takes 15-30 minutes to fit; if you'd rather not wait, you can load a 
saved version of the fitted model for this example using the command 
`mod <- openpop_example$mod`)
```{r, eval = FALSE}
mod$fit()
```

While fitting, the likelihood will be printed for each evaluation. Once fit, 
parameter estimates can be viewed by typing the name of the model object
into the console. 
```{r, echo = FALSE}
mod <- openpop_example$mod
```
```{r}
mod
```

The parameter estimates table gives estimates on the link scale. This is useful
later when covariates are used. The link functions for each parameter are set: 
lambda0, sigma, and D have log link functions, beta has a multilogistic link 
function, and phi has a logit link function. 

Note that the variance and 
confidence intervals for density in each occasion are computed using a bootstrap
and so will vary each time the model is fit. The number of re-samples in the 
bootstrap is 100 by default and can be changed by providing an additional 
argument to the `$fit` method, e.g.
```{r, eval = FALSE}
mod$fit(nsims = 1000)
```
Alternatively, if the model has already been fit, but you wish to generate 
more re-samples to improve variance estimates, see the section on simulating
density and recruitment below. 

## Covariates

Covariates are included similarly to linear regression. Covariates can change
with occasion or detector or both. Covariate information is loaded with the data
into a `ScrData` object. Every `ScrData` object contains a default covariate
`t`: a factor variable denoting the occasion. For this reason, the user should
not name any custom covariates `t`. 

For example, suppose an environmental impact, from  a change in management
policy, occurred in the middle of the survey, just after occasion 5 in our
example data. A covariate `impact` can be created with a `0` value for occasions
1 to 5 and a value of `1` for occasions 6 to 10. This is a factor variable,
labelling occasions before and after impact.
```{r}
impact <- factor(c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1))
```

A new `ScrData` object is created with this covariate included. Each covariate
must be given a "type" to indicate in what way this covariate changes: 

- If the covariate has the same value for all detectors and changes with
	occasion, it is of type "k" and must be a vector of length equal to the number
	of occasions. 
- If the covariate has the same value for all occasions and changes with
	detector it is of type "j" and must be a vector of length equal to the number
	of detectors. 
- If the covariate has a different value for each detector and occasion, it is of type "jk" and must be a matrix with the number of rows equal to the number of detectors and the number of columns equal to the number of occasions such that the (j, k) entry is the covariate value for the detector j on occasion k. 

For this example, `impact` is a "k" type covariate: 
```{r}
scr_dat <- ScrData$new(capture_history, mesh, cov = list(impact = impact), cov_type = c("k")) 
```

The `ScrData` object can be queried to give the value of the covariate for any
(j, k) combination. 
```{r}
# get covariates for detector 1 on occasion 2 
scr_dat$covs(j = 1, k = 2)
# get covariates for detector 2 across all occasions  
scr_dat$covs(j = 2)
```
Recall, the covariate `t` is included by default in all `ScrData` objects. 

A model can then be fit allowing for parameters to depend on covariates included
in the `ScrData` object.
```{r}
par <- list(lambda0 ~ 1, 
            sigma ~ 1, 
            beta ~ 1, 
            phi ~ impact)

# guess a reasonable start value for each parameter 
start <- list(lambda0 = 2.0, 
              sigma = 100, 
              beta = 0.2, 
              phi = 0.5, 
              D = 100)

# create JsModel object 
impact_mod <- JsModel$new(par, scr_dat, start)
```

The model is fit usual way and similar output obtained. (If you would rather
not wait for it to fit, you can load the fitted model using `impact_mod <- openpop_example$impact_mod`) 
```{r, eval = FALSE}
impact_mod$fit()
```
```{r, echo = FALSE}
impact_mod <- openpop_example$impact_mod
```
```{r}
impact_mod 
```

### Time-varying parameters

A occasion-specific effect can be included for any parameter. For example,
mean encounter rate may differ across occasions and this variation may not be
explained by any recorded covariates. Similarly, arrival rate, beta, may vary
over time due to unknown variables that affect fecundity or migration. A
built-in covariate to every `ScrData` object is `t` and allows for a seperate
parameter to be estimated for each occasion.

For example, a model where mean arrival rate, beta, is different for every
occasion can be fit.

```{r}
par <- list(lambda0 ~ 1, 
            sigma ~ 1, 
            beta ~ t, 
            phi ~ 1)

# guess a reasonable start value for each parameter 
start <- list(lambda0 = 2.0, 
              sigma = 100, 
              beta = 0.2, 
              phi = 0.5, 
              D = 100)

# create JsModel object 
t_mod <- JsModel$new(par, scr_dat, start)
```

The model is fit in the usual way. (If you would rather not wait for it to fit,
you can load the fitted model using `t_mod <- openpop_example$t_mod`.)

```{r, eval = FALSE}
t_mod$fit()
```
```{r, echo = FALSE}
t_mod <- openpop_example$t_mod
```
```{r}
t_mod 
```

Note, that when phi depends on t, only survival for every occasion but the last
is estimated, since there is no information in the data on how many animals
survived the final occasion.

## Model Selection 

Models can be compared using Akaike Information Criterion (AIC). In this
example, is it necessary for lambda0 to vary with occasion? 
```{r}
AIC(mod, t_mod) 
```
The model with time-varying beta has a marginally better AIC and would be selected for 
inference. 

Whether or not to include other covariates can also be determined by comparing
AIC.

## Model checking 

Once a model is selected, you can check whether the model fits the data well or
where the model fits it poorly. This can be done by predictive checking:
simulating new data from the model and comparing it to the real data. How the
simulated and real data are compared is up to the analyst. The comparison should
focus on key attributes of the data, that is, those aspects that are of most
interest to the biological hypotheses.

This package does not do the comparison for you, but does provide a function to
simulate new data from a fitted model. 
```{r, fig.show = "hold", fig.width = 5, fig.height = 5, fig.align = "center"}
# simulate a new data
new_data <- mod$simulate()
new_data
```


## Drawing inference

Estimated parameters and their confidence intervals are given by typing the name
of the model object into the console.  
```{r}
impact_mod
```

In particular, estimates of density per square kilometre is output for each each
occasion. Furthermore, confidence intervals allow you to evaluate the
statistical evidence for each covariates effect. Here, for example, impact has a
confidence interval overlapping zero, indicating no evidence that the impact
affected survival. 

Estimates can be extracted in a simple to use list: 
```{r}
impact_mod$estimates()
```

Finally, parameters on the response scale can be computed for given covariate values: 
```{r}
# get survival for occasion 1
impact_mod$get_par("phi", k = 1)
# get survival for all occasions 
impact_mod$get_par("phi")
```

The `$get_par` method can extract parameters lambda0, sigma, phi, and beta on the response scale.

Plots of parameter values over occasion can be produced: 
```{r, fig.show = "hold", fig.width = 5, fig.height = 5, fig.align = "center"}
# get plot of proportion of total 
# population that arrives in each occasion
betas <- t_mod$get_par("beta") 
# exclude beta[1] as it is the proportion
# alive before occasion 1 
plot(scr_dat$time()[-1], betas[-1], type = "l", xlab = "Time", ylab =
"Probability of arrival") 
```

### Simulating density and recruitment

Population density and recruitment numbers can be simulated from the model. 
The samples obtained can be used for model checking, variance estimation, or Monte Carlo testing 
of biological hypotheses about the population.
```{r, echo = FALSE}
set.seed(12531)
```
```{r, fig.show = "hold", fig.width = 5, fig.height = 5, fig.align = "center"}
density_samples <- t_mod$sample_D(nsims = 100)
# plot density trajectories 
matplot(scr_dat$time(), t(density_samples), type = "l", xlab = "Time", ylab =
"Density (per sq. km)")
```

Recruitment is the number of animals that enter the population on each occasion.
```{r, fig.show = "hold", fig.width = 5, fig.height = 5, fig.align = "center"}
recruit_samples  <- t_mod$sample_R(nsims = 100)
# plot recruitment numbers for occasion > 1
# as number of recuits on occasion 1 is 
# number alive before the survey started 
matplot(scr_dat$time()[-1], t(recruit_samples[,-1]), type = "l", xlab = "Time",
ylab = "Recruits (per sq. km)")
```

## References

